<!doctype html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <title>MSTSP Visualization</title>
    <style>
      canvas {
        touch-action: none;
      }
    </style>
    <script src="src/tests/mstsp.js"></script>
    <script src="src/tests/7-11超商.js"></script>
    <script src="src/tests/萊爾富.js"></script>
    <script src="src/tests/全家.js"></script>
    <script src="src/tests/OK超商.js"></script>
    <script src="src/solutions/hga.js"></script>
  </head>
  <body
    class="bg-gray-900 text-white h-screen flex flex-col overflow-hidden"
    x-data="mtspApp()"
    x-init="initApp()"
  >
    <!-- Header / Controls -->
    <header
      class="p-4 bg-gray-800 shadow-lg z-10 flex flex-wrap gap-6 items-center justify-between border-b border-gray-700"
    >
      <div class="flex items-top gap-3">
        <div class="p-2 bg-purple-600 rounded-lg">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-6 w-6 text-white"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 7m0 13V7m0 0L9.553 4.553A1 1 0 009 3.618"
            />
          </svg>
        </div>
        <div>
          <h1 class="text-xl font-bold text-gray-100 tracking-wide">
            Multi-Solution TSP
          </h1>
          <div class="text-xs text-gray-400">多解路徑規劃</div>
        </div>
      </div>

      <div class="flex flex-wrap gap-6 items-end">
        <!-- Problem ID Control -->
        <div class="flex flex-col gap-1">
          <label class="text-xs text-gray-400 font-medium">問題 ID</label>
          <select
            x-model="problemId"
            @change="reset()"
            class="bg-gray-700 text-white text-xs rounded px-2 py-1 border border-gray-600 focus:outline-none focus:border-blue-500 h-[26px] w-32"
          >
            <optgroup label="MSTSP Benchmarks">
              <template x-for="i in 25">
                <option :value="`MSTSP-${i}`" x-text="`MSTSP-${i}`"></option>
              </template>
            </optgroup>
            <optgroup label="超商">
              <template
                x-for="id in Object.keys(problems).filter(k => !k.startsWith('MSTSP-'))"
              >
                <option :value="id" x-text="id"></option>
              </template>
            </optgroup>
          </select>
        </div>

        <!-- Buttons -->
        <div class="flex gap-3">
          <button
            @click="exportState()"
            class="px-4 py-1.5 bg-gray-700 hover:bg-gray-600 rounded text-sm font-medium transition border border-gray-600 hover:border-gray-500"
          >
            匯出
          </button>
          <button
            @click="$refs.fileInput.click()"
            class="px-4 py-1.5 bg-gray-700 hover:bg-gray-600 rounded text-sm font-medium transition border border-gray-600 hover:border-gray-500"
          >
            匯入
          </button>
          <input
            x-ref="fileInput"
            type="file"
            style="display: none"
            @change="importState($event)"
            accept=".json"
          />
          <button
            @click="reset()"
            class="px-4 py-1.5 bg-gray-700 hover:bg-gray-600 rounded text-sm font-medium transition border border-gray-600 hover:border-gray-500"
          >
            重置
          </button>
          <button
            @click="toggle()"
            class="px-4 py-1.5 rounded text-sm font-bold transition w-24 shadow-lg"
            :class="running ? 'bg-red-500 hover:bg-red-600 text-white shadow-red-500/30' : 'bg-blue-500 hover:bg-blue-600 text-white shadow-blue-500/30'"
            x-text="running ? '停止' : '開始'"
          ></button>
        </div>
      </div>
    </header>
    <aside class="absolute sm:top-40 md:top-24 top-54 right-3 z-10 flex flex-col items-end min-w-[100px]">
      <div class="text-xs text-gray-400">最佳距離</div>
      <div
        x-text="globalBestDistance.toFixed(0) + (problemId.startsWith('MSTSP-') ? '' : ' km')"
        class="text-white font-mono text-xl font-bold text-shadow"
      >
        0
      </div>
      <div class="text-xs text-gray-500 mt-1">
        迭代:
        <span x-text="generation" class="font-mono text-gray-300">0</span>
      </div>

      <!-- Metrics Display -->
      <div class="mt-2 flex flex-col items-end" x-show="groundTruth[problemId]">
        <div class="text-[10px] text-gray-400 uppercase tracking-wider mb-0.5">
          F-Beta
        </div>
        <div
          class="text-sm font-mono font-bold"
          :class="fBeta > 0.8 ? 'text-green-400' : 'text-yellow-400'"
          x-text="fBeta.toFixed(3)"
        >
          0.000
        </div>

        <div
          class="text-[10px] text-gray-400 uppercase tracking-wider mt-1 mb-0.5"
        >
          Diversity
        </div>
        <div
          class="text-sm font-mono font-bold text-blue-400"
          x-text="diversity.toFixed(3)"
        >
          0.000
        </div>
      </div>
    </aside>
    <!-- Main Canvas Area -->
    <main
      class="flex-1 relative bg-gray-900 cursor-crosshair overflow-hidden"
      id="canvas-container"
    >
      <canvas
        id="mainCanvas"
        class="block w-full h-full cursor-grab active:cursor-grabbing"
        @mousedown="startDrag($event)"
        @mousemove="handleMouseMove($event)"
        @mouseup="stopDrag()"
        @mouseleave="handleMouseLeave()"
      ></canvas>

      <!-- Legend -->
      <div
        class="absolute bottom-6 left-6 bg-gray-800/90 rounded-xl backdrop-blur-md border border-gray-700 shadow-xl flex flex-col max-h-[70vh]"
      >
        <!-- Header -->
        <div class="p-4 pb-2 shrink-0">
          <div class="flex justify-between items-center mb-3 gap-4">
            <h3
              class="text-xs font-bold text-gray-400 uppercase tracking-wider"
            >
              圖例
            </h3>
            <button
              @click="drawingEnabled = !drawingEnabled; if(drawingEnabled && !running) draw()"
              class="text-[10px] px-2 py-0.5 rounded border transition-colors font-mono"
              :class="drawingEnabled ? 'bg-green-500/20 text-green-400 border-green-500/50' : 'bg-gray-700 text-gray-400 border-gray-600'"
              x-text="drawingEnabled ? '繪圖 ON' : '繪圖 OFF'"
            ></button>
          </div>
          <div class="flex items-center gap-3 mb-2">
            <div
              class="w-3 h-3 rounded-full bg-white shadow-[0_0_8px_rgba(255,255,255,0.5)]"
            ></div>
            <span class="text-sm text-gray-200">城市 (City)</span>
          </div>
          <div class="flex items-center gap-3 mb-4">
            <div
              class="w-5 h-5 bg-red-500 rounded flex items-center justify-center text-[10px] font-bold shadow-[0_0_8px_rgba(239,68,68,0.5)]"
            >
              D
            </div>
            <span class="text-sm text-gray-200">倉庫 (Depot)</span>
          </div>

          <h3
            class="text-xs font-bold text-gray-400 mb-2 uppercase tracking-wider"
          >
            解決方案 (Solutions)
          </h3>
        </div>

        <!-- Scrollable List -->
        <div class="overflow-y-auto px-4 min-h-0">
          <template x-for="node in nodes" :key="node.id">
            <div
              class="flex items-center gap-3 mb-1 cursor-pointer hover:bg-gray-700/50 p-1 rounded"
              x-show="node.type === 'leaf'"
              @click="node.visible = !node.visible; if(!running) draw()"
            >
              <div
                class="w-3 h-3 rounded border flex items-center justify-center transition-colors"
                :class="node.visible ? 'bg-blue-500 border-blue-500' : 'border-gray-500 bg-transparent'"
              >
                <svg
                  x-show="node.visible"
                  class="w-2 h-2 text-white"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="4"
                    d="M5 13l4 4L19 7"
                  ></path>
                </svg>
              </div>
              <div
                class="w-8 h-1 rounded"
                :style="`background-color: ${node.color}; opacity: ${node.visible ? 1 : 0.3}`"
              ></div>
              <span
                class="text-xs text-gray-300 font-mono select-none"
                x-text="`Sol ${node.id}: ${(!node.bestDistance || node.bestDistance === Infinity) ? '-' : node.bestDistance.toFixed(0) + (problemId.startsWith('MSTSP-') ? '' : ' km')}`"
                :class="{'opacity-50': !node.visible}"
              ></span>
            </div>
          </template>
        </div>

        <!-- Sticky Footer -->
        <div
          class="p-4 pt-3 border-t border-gray-700 shrink-0 bg-gray-800/50 rounded-b-xl"
        >
          <div class="flex justify-between text-xs text-gray-400 mb-1">
            <span>最佳距離:</span>
            <span
              class="font-mono text-gray-200 font-bold"
              x-text="globalBestDistance === Infinity ? '-' : (globalBestDistance.toFixed(0) + (problemId.startsWith('MSTSP-') ? '' : ' km'))"
            ></span>
          </div>
          <div class="flex justify-between text-xs text-gray-400 mb-1">
            <span>最佳解耗時:</span>
            <span
              class="font-mono text-gray-200"
              x-text="bestTime + ' s'"
            ></span>
          </div>
          <div class="flex justify-between text-xs text-gray-400">
            <span>最佳解迭代:</span>
            <span
              class="font-mono text-gray-200"
              x-text="bestGeneration"
            ></span>
          </div>
        </div>
      </div>

      <!-- Zoom Controls -->
      <div class="absolute bottom-6 right-6 flex flex-row gap-2 items-center">
        <div class="text-xs font-mono text-gray-300 bg-gray-800/90 rounded px-2 py-1 border border-gray-700 shadow-xl backdrop-blur-md min-w-[3.5rem] text-center select-none">
            <span x-text="Math.round(zoomLevel * 100) + '%'"></span>
        </div>
        <button
          @click="zoomOut()"
          class="p-2 bg-gray-800/90 hover:bg-gray-700 rounded-lg backdrop-blur-md border border-gray-700 shadow-xl text-white transition-colors"
          title="Zoom Out"
        >
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4" />
          </svg>
        </button>
        <button
          @click="zoomIn()"
          class="p-2 bg-gray-800/90 hover:bg-gray-700 rounded-lg backdrop-blur-md border border-gray-700 shadow-xl text-white transition-colors"
          title="Zoom In"
        >
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
          </svg>
        </button>
      </div>
    </main>

    <script>
      function mtspApp() {
        return {
          ...getHGALogic(),
          cityCount: 30,
          solutionCount: 0, // Initial number of islands
          problemId: "MSTSP-1",
          foundOptima: new Set(),
          groundTruth: {
            "MSTSP-1": { optLength: 680, optCount: 3 },
            "MSTSP-2": { optLength: 1265, optCount: 4 },
            "MSTSP-3": { optLength: 832, optCount: 13 },
            "MSTSP-4": { optLength: 803, optCount: 4 },
            "MSTSP-5": { optLength: 754, optCount: 2 },
            "MSTSP-6": { optLength: 845, optCount: 4 },
            "MSTSP-7": { optLength: 130, optCount: 56 },
            "MSTSP-8": { optLength: 1344, optCount: 110 },
            "MSTSP-9": { optLength: 72, optCount: 4 },
            "MSTSP-10": { optLength: 72, optCount: 4 },
            "MSTSP-11": { optLength: 78, optCount: 14 },
            "MSTSP-12": { optLength: 130, optCount: 196 },
            "MSTSP-13": { optLength: 3055, optCount: 70 },
            "MSTSP-14": { optLength: 3575, optCount: 16 },
            "MSTSP-15": { optLength: 9455, optCount: 72 },
            "MSTSP-16": { optLength: 8761, optCount: 64 },
            "MSTSP-17": { optLength: 9061, optCount: 10 },
            "MSTSP-18": { optLength: 23763, optCount: 20 },
            "MSTSP-19": { optLength: 14408, optCount: 20 },
            "MSTSP-20": { optLength: 10973, optCount: 20 },
            "MSTSP-21": { optLength: 6767, optCount: 4 },
            "MSTSP-22": { optLength: 10442, optCount: 9 },
            "MSTSP-23": { optLength: 24451, optCount: 10 },
            "MSTSP-24": { optLength: 9614, optCount: 36 },
            "MSTSP-25": { optLength: 9521, optCount: 26 },
          },
          problems: {
            ...mstspProblems,
            ...unimart,
            ...familymart,
            ...okmart,
            ...hilife,
          },
          running: false,
          generation: 0,
          globalBestDistance: 0,

          // Internal state
          canvas: null,
          ctx: null,
          width: 0,
          height: 0,
          cities: [],
          depot: { x: 0, y: 0 },

          // Evaluation coordinates (Original scale for Fixed, Screen scale for Random)
          evalCities: [],
          evalDepot: { x: 0, y: 0 },

          mouseX: -1,
          mouseY: -1,

          // Metrics
          fBeta: 0,
          diversity: 0,
          drawingEnabled: true,
          zoomLevel: 1,
          panX: 0,
          panY: 0,
          isDragging: false,
          dragStartX: 0,
          dragStartY: 0,

          // Timing & Stats
          startTime: null,
          bestTime: 0,
          bestGeneration: 0,

          zoomIn() {
            this.zoomLevel *= 1.2;
            this.updateScreenCoordinates();
            if (!this.running) this.draw();
          },

          zoomOut() {
            this.zoomLevel /= 1.2;
            this.updateScreenCoordinates();
            if (!this.running) this.draw();
          },

          generateCities(id) {
            if (this.problems[id]) {
              const data = this.problems[id];

              if (id.startsWith("MSTSP-")) {
                // Extract Depot (First point) and Cities (Rest)
                this.originalDepot = data[0];
                this.originalCities = data.slice(1);
              } else {
                // For convenience stores, use specific depot
                // 25.033276, 121.434686 (Lat, Lon) -> (y, x)
                this.originalDepot = { x: 121.434686, y: 25.033276 };
                this.originalCities = data;
              }

              this.cityCount = this.originalCities.length;

              // Find bounds (using ALL points including depot)
              let minX = Infinity,
                maxX = -Infinity;
              let minY = Infinity,
                maxY = -Infinity;

              const allPoints = [this.originalDepot, ...this.originalCities];
              allPoints.forEach((p) => {
                if (p.x < minX) minX = p.x;
                if (p.x > maxX) maxX = p.x;
                if (p.y < minY) minY = p.y;
                if (p.y > maxY) maxY = p.y;
              });

              this.bounds = { minX, maxX, minY, maxY };
              this.updateScreenCoordinates();
            }
          },

          updateScreenCoordinates() {
            if (!this.bounds || !this.originalDepot) return;
            const { minX, maxX, minY, maxY } = this.bounds;

            const margin = 50;
            const availW = this.width - 2 * margin;
            const availH = this.height - 2 * margin;

            const rangeX = maxX - minX;
            const rangeY = maxY - minY;

            // Scale to fit while maintaining aspect ratio
            const scaleX = rangeX === 0 ? 1 : availW / rangeX;
            const scaleY = rangeY === 0 ? 1 : availH / rangeY;
            const scale = Math.min(scaleX, scaleY) * this.zoomLevel;

            // Center the content
            const contentW = rangeX * scale;
            const contentH = rangeY * scale;
            const offsetX = margin + (availW - contentW) / 2 + this.panX;
            const offsetY = margin + (availH - contentH) / 2 + this.panY;

            // Set Screen Coordinates
            // Note: For maps (lat/lon), Y usually increases upwards (North),
            // but Canvas Y increases downwards. So we need to invert Y.

            this.depot = {
              x: offsetX + (this.originalDepot.x - minX) * scale,
              y: offsetY + (maxY - this.originalDepot.y) * scale, // Invert Y
            };

            this.cities = this.originalCities.map((p) => ({
              x: offsetX + (p.x - minX) * scale,
              y: offsetY + (maxY - p.y) * scale, // Invert Y
            }));
          },

          // HGA Structure
          // Tree Topology: 1 Root -> 3 Leaves (Sub-populations)
          // Node structure: { id, population, bestGenome, bestDistance, color }
          nodes: [],
          workers: [], // Web Workers

          // Parameters
          popSize: 100,
          migrationInterval: 10,
          clearingRadius: 0.2, // Similarity threshold for clearing (20%)

          // Visualization colors for different solutions
          solutionColors: [
            "#00ffff", // Cyan
            "#ff00ff", // Magenta
            "#ffff00", // Yellow
            "#00ff00", // Green
            "#ff8800", // Orange
          ],

          // Path colors for salesmen within a solution (if m > 1)
          salesmenColors: [
            "#3490dc",
            "#ffed4a",
            "#38c172",
            "#e3342f",
            "#9561e2",
            "#f66d9b",
            "#6574cd",
            "#4dc0b5",
            "#f6993f",
            "#6cb2eb",
          ],

          initApp() {
            this.canvas = document.getElementById("mainCanvas");
            this.ctx = this.canvas.getContext("2d");

            const resize = () => {
              const container = document.getElementById("canvas-container");
              this.canvas.width = container.clientWidth;
              this.canvas.height = container.clientHeight;
              this.width = this.canvas.width;
              this.height = this.canvas.height;
              this.updateScreenCoordinates();
              if (!this.running) this.draw();
            };
            window.addEventListener("resize", resize);
            resize();

            this.reset();
          },

          exportState() {
            const state = {
              problemId: this.problemId,
              generation: this.generation,
              globalBestDistance: this.globalBestDistance,
              nodes: this.nodes.map((n) => ({
                id: n.id,
                type: n.type,
                bestGenome: n.bestGenome,
                bestDistance: n.bestDistance,
                color: n.color,
                visible: n.visible,
              })),
              fBeta: this.fBeta,
              diversity: this.diversity,
              bestTime: this.bestTime,
              bestGeneration: this.bestGeneration,
              timestamp: new Date().toISOString(),
            };

            const blob = new Blob([JSON.stringify(state, null, 2)], {
              type: "application/json",
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `mstsp-state-${this.problemId}-${this.generation}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          },

          importState(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const state = JSON.parse(e.target.result);
                this.loadState(state);
              } catch (err) {
                console.error("Failed to load state:", err);
                alert("匯入失敗：檔案格式錯誤 (" + err.message + ")");
              }
              event.target.value = "";
            };
            reader.readAsText(file);
          },

          loadState(state) {
            this.stop();

            if (!state || !state.nodes || !Array.isArray(state.nodes)) {
              throw new Error("Invalid state file format: missing nodes");
            }

            // 1. Restore Problem ID and Environment
            if (state.problemId) {
              this.problemId = state.problemId;
            }

            // Regenerate cities based on the ID (updates originalCities, cityCount, bounds)
            this.generateCities(this.problemId);

            // CRITICAL: Update evaluation context to match the new problem
            // This ensures workers get the correct coordinates
            this.evalCities = this.originalCities;
            this.evalDepot = this.originalDepot;

            // 2. Restore Metrics
            this.generation = state.generation || 0;
            this.globalBestDistance = state.globalBestDistance || Infinity;
            this.fBeta = state.fBeta || 0;
            this.diversity = state.diversity || 0;
            this.bestTime = state.bestTime || 0;
            this.bestGeneration = state.bestGeneration || 0;

            // 3. Restore Nodes
            this.nodes = state.nodes.map((n) => ({
              ...n,
              population: [], // Population is not exported, will be re-initialized
            }));

            // 4. Re-initialize Workers
            if (this.workers) {
              this.workers.forEach((w) => w.terminate());
            }
            this.workers = [];

            this.nodes.forEach((node) => {
              if (node.type === "leaf") {
                const worker = new Worker("src/solutions/worker.js");

                worker.onmessage = (e) => {
                  const { type, bestGenome, bestDistance } = e.data;
                  if (type === "init_done") {
                    // If the worker found a better solution (or just initialized), update
                    // But we want to keep the imported best if it's better
                    if (bestDistance < node.bestDistance) {
                      node.bestDistance = bestDistance;
                      node.bestGenome = bestGenome;
                    }
                    if (!this.running) this.draw();
                  } else if (type === "update") {
                    node.bestGenome = bestGenome;
                    node.bestDistance = bestDistance;
                    if (bestDistance < this.globalBestDistance) {
                      this.globalBestDistance = bestDistance;
                      this.bestGeneration = this.generation;
                      if (this.startTime) {
                        this.bestTime = (
                          (Date.now() - this.startTime) /
                          1000
                        ).toFixed(2);
                      }
                    }
                  }
                };

                worker.postMessage({
                  type: "init",
                  data: {
                    cityCount: this.cityCount,
                    evalCities: JSON.parse(JSON.stringify(this.evalCities)),
                    evalDepot: JSON.parse(JSON.stringify(this.evalDepot)),
                    problemId: this.problemId,
                    popSize: this.popSize,
                    groundTruth: JSON.parse(
                      JSON.stringify(this.groundTruth || {}),
                    ),
                    nodeId: node.id,
                    initialBestGenome: node.bestGenome
                      ? JSON.parse(JSON.stringify(node.bestGenome))
                      : null,
                  },
                });

                this.workers.push(worker);
              }
            });

            this.draw();
          },

          scheduleReset() {
            if (this.resetTimeout) clearTimeout(this.resetTimeout);
            this.resetTimeout = setTimeout(() => this.reset(), 100);
          },

          reset() {
            this.stop();
            this.generation = 0;
            this.globalBestDistance = Infinity;
            this.foundOptima = new Set();
            this.fBeta = 0;
            this.diversity = 0;
            this.zoomLevel = 1;
            this.panX = 0;
            this.panY = 0;

            this.startTime = null;
            this.bestTime = 0;
            this.bestGeneration = 0;

            // Initialize Cities & Depot
            this.generateCities(this.problemId);

            // Set solution count based on ground truth
            if (this.groundTruth[this.problemId]) {
              this.solutionCount = this.groundTruth[this.problemId].optCount;
            } else {
              this.solutionCount = 5;
            }

            // Use Original Coordinates for Evaluation
            this.evalCities = this.originalCities;
            this.evalDepot = this.originalDepot;

            // Initialize HGA Tree Structure
            this.nodes = [];
            // this.bestSolutions = []; // Removed, using nodes directly

            // Create Root Node (ID: 0)
            this.nodes.push({
              id: 0,
              type: "root",
              population: [],
              bestGenome: null,
              bestDistance: Infinity,
              color: "#ffffff",
              visible: false,
            });

            // Create Leaf Nodes (ID: 1 to k)
            for (let k = 0; k < this.solutionCount; k++) {
              const color = this.solutionColors[k % this.solutionColors.length];

              // Create Node
              this.nodes.push({
                id: k + 1,
                type: "leaf",
                population: [],
                bestGenome: null,
                bestDistance: Infinity,
                color: color,
                visible: true,
              });
            }

            // Initialize Populations for all nodes
            // Terminate old workers
            if (this.workers) {
              this.workers.forEach((w) => w.terminate());
            }
            this.workers = [];

            // Initialize Workers for Leaf Nodes
            this.nodes.forEach((node) => {
              if (node.type === "leaf") {
                const worker = new Worker("src/solutions/worker.js");

                worker.onmessage = (e) => {
                  const { type, bestGenome, bestDistance, generation } = e.data;
                  if (type === "init_done") {
                    node.bestDistance = bestDistance;
                    node.bestGenome = bestGenome;
                    // Update global best immediately after init
                    if (bestDistance < this.globalBestDistance) {
                      this.globalBestDistance = bestDistance;
                    }
                    // Draw immediately to show initial state
                    if (!this.running) this.draw();
                  } else if (type === "update") {
                    node.bestGenome = bestGenome;
                    node.bestDistance = bestDistance;
                    // Update global best
                    if (bestDistance < this.globalBestDistance) {
                      this.globalBestDistance = bestDistance;
                      this.bestGeneration = this.generation;
                      if (this.startTime) {
                        this.bestTime = (
                          (Date.now() - this.startTime) /
                          1000
                        ).toFixed(2);
                      }
                    }
                  }
                };

                worker.postMessage({
                  type: "init",
                  data: {
                    cityCount: this.cityCount,
                    evalCities: JSON.parse(JSON.stringify(this.evalCities)),
                    evalDepot: JSON.parse(JSON.stringify(this.evalDepot)),
                    problemId: this.problemId,
                    popSize: this.popSize,
                    groundTruth: JSON.parse(
                      JSON.stringify(this.groundTruth || {}),
                    ),
                    nodeId: node.id,
                  },
                });

                this.workers.push(worker);
              }
            });

            // this.evaluate(); // Workers do this now
            // this.draw(); // Moved to worker callback
          },

          toggle() {
            if (this.running) this.stop();
            else this.start();
          },

          start() {
            if (this.running) return;
            if (!this.startTime) this.startTime = Date.now();
            this.running = true;
            this.workers.forEach((w) => w.postMessage({ type: "start" }));
            this.loop();
          },

          stop() {
            this.running = false;
            this.workers.forEach((w) => w.postMessage({ type: "stop" }));
            if (this.animationId) {
              cancelAnimationFrame(this.animationId);
              this.animationId = null;
            }
          },

          loop() {
            if (!this.running) return;

            // Workers are running in background.
            // We just update the generation counter and draw.
            this.generation++; // Approximate counter

            // --- Migration Logic (Crucial for Convergence) ---
            // Every few frames, gather best solutions from all islands and broadcast them
            // Increased frequency: migrate every 2 frames instead of 10
            if (this.generation % 2 === 0) {
              const migrants = [];
              this.nodes.forEach((n) => {
                if (n.type === "leaf" && n.bestGenome) {
                  migrants.push(n.bestGenome);
                }
              });

              if (migrants.length > 0) {
                // Remove Proxies to avoid cloning errors
                const cleanMigrants = JSON.parse(JSON.stringify(migrants));
                this.workers.forEach((w) => {
                  w.postMessage({
                    type: "migrate_in",
                    data: { migrants: cleanMigrants },
                  });
                });
              }
            }

            // Calculate metrics occasionally
            if (this.generation % 10 === 0) {
              this.calculateMetrics();
              this.handleDuplicates();
            }

            if (this.fBeta >= 1) {
              this.stop();
              this.draw();
              return;
            }

            if (this.drawingEnabled) {
              this.draw();
            }

            this.animationId = requestAnimationFrame(() => this.loop());
          },

          // --- Drawing ---

          startDrag(e) {
            this.isDragging = true;
            this.dragStartX = e.clientX;
            this.dragStartY = e.clientY;
          },

          stopDrag() {
            this.isDragging = false;
          },

          handleMouseMove(e) {
            const rect = this.canvas.getBoundingClientRect();
            this.mouseX = e.clientX - rect.left;
            this.mouseY = e.clientY - rect.top;

            if (this.isDragging) {
                const dx = e.clientX - this.dragStartX;
                const dy = e.clientY - this.dragStartY;
                this.panX += dx;
                this.panY += dy;
                this.dragStartX = e.clientX;
                this.dragStartY = e.clientY;
                this.updateScreenCoordinates();
            }

            if (!this.running) this.draw();
          },

          handleMouseLeave() {
            this.stopDrag();
            this.mouseX = -1;
            this.mouseY = -1;
            if (!this.running) this.draw();
          },

          pointToLineDistance(x, y, x1, y1, x2, y2) {
            const A = x - x1;
            const B = y - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const len_sq = C * C + D * D;
            let param = -1;
            if (len_sq !== 0) param = dot / len_sq;

            let xx, yy;

            if (param < 0) {
              xx = x1;
              yy = y1;
            } else if (param > 1) {
              xx = x2;
              yy = y2;
            } else {
              xx = x1 + param * C;
              yy = y1 + param * D;
            }

            const dx = x - xx;
            const dy = y - yy;
            return Math.sqrt(dx * dx + dy * dy);
          },

          isMouseOnPath(genome) {
            if (this.mouseX < 0) return false;
            const threshold = 8; // Tolerance in pixels
            let currentPos = this.depot;

            for (let i = 0; i < genome.length; i++) {
              const index = genome[i];
              const nextPos = this.cities[index];

              if (
                this.pointToLineDistance(
                  this.mouseX,
                  this.mouseY,
                  currentPos.x,
                  currentPos.y,
                  nextPos.x,
                  nextPos.y,
                ) < threshold
              ) {
                return true;
              }

              currentPos = nextPos;
            }

            // Last segment back to depot
            if (
              this.pointToLineDistance(
                this.mouseX,
                this.mouseY,
                currentPos.x,
                currentPos.y,
                this.depot.x,
                this.depot.y,
              ) < threshold
            ) {
              return true;
            }

            return false;
          },

          drawTooltip(text, x, y) {
            this.ctx.font = "12px sans-serif";
            const metrics = this.ctx.measureText(text);
            const padding = 6;
            const w = metrics.width + padding * 2;
            const h = 24;

            // Keep tooltip within bounds
            let tx = x + 10;
            let ty = y - 10;
            if (tx + w > this.width) tx = x - w - 10;
            if (ty < 0) ty = y + 20;

            this.ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
            this.ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
            this.ctx.lineWidth = 1;

            this.ctx.beginPath();
            this.ctx.roundRect(tx, ty, w, h, 4);
            this.ctx.fill();
            this.ctx.stroke();

            this.ctx.fillStyle = "white";
            this.ctx.textBaseline = "middle";
            this.ctx.textAlign = "left";
            this.ctx.fillText(text, tx + padding, ty + h / 2);
          },

          handleDuplicates() {
            const leaves = this.nodes.filter(
              (n) => n.type === "leaf" && n.bestGenome,
            );
            const seenSignatures = new Map(); // signature -> nodeId

            leaves.forEach((node) => {
              // Use canonical signature to detect identical solutions (path direction/start invariant)
              const sig = this.getCanonicalSignature(node.bestGenome);

              if (seenSignatures.has(sig)) {
                // Duplicate found! Restart this node to find a different solution
                const workerIndex = node.id - 1; // Node IDs are 1-based, workers array is 0-based
                const worker = this.workers[workerIndex];

                if (worker) {
                  // Re-initialize the worker
                  worker.postMessage({
                    type: "init",
                    data: {
                      cityCount: this.cityCount,
                      evalCities: JSON.parse(JSON.stringify(this.evalCities)),
                      evalDepot: JSON.parse(JSON.stringify(this.evalDepot)),
                      problemId: this.problemId,
                      popSize: this.popSize,
                      groundTruth: JSON.parse(
                        JSON.stringify(this.groundTruth || {}),
                      ),
                      nodeId: node.id,
                    },
                  });
                  // Reset node stats visually
                  node.bestDistance = Infinity;
                  node.bestGenome = null;
                }
              } else {
                seenSignatures.set(sig, node.id);
              }
            });
          },

          draw() {
            if (!this.drawingEnabled) return;

            this.ctx.fillStyle = "#111827";
            this.ctx.fillRect(0, 0, this.width, this.height);

            // Draw Solutions (Leaves)
            // Iterate through nodes directly
            for (let k = this.nodes.length - 1; k >= 0; k--) {
              const node = this.nodes[k];
              if (node.type === "leaf" && node.bestGenome && node.visible) {
                this.drawPath(node.bestGenome, node.color, false);
              }
            }

            // Draw Cities
            this.cities.forEach((city) => {
              this.ctx.beginPath();
              this.ctx.arc(city.x, city.y, 4, 0, Math.PI * 2);
              this.ctx.fillStyle = "white";
              this.ctx.fill();
            });

            // Draw Depot
            this.ctx.beginPath();
            this.ctx.rect(this.depot.x - 8, this.depot.y - 8, 16, 16);
            this.ctx.fillStyle = "#ef4444";
            this.ctx.fill();
            this.ctx.strokeStyle = "white";
            this.ctx.lineWidth = 2;
            this.ctx.stroke();
            this.ctx.fillStyle = "white";
            this.ctx.font = "bold 10px sans-serif";
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";
            this.ctx.fillText("D", this.depot.x, this.depot.y);

            // --- Interaction ---
            let hoveredCity = null;
            let hoveredNode = null;

            // Check cities
            for (let i = 0; i < this.cities.length; i++) {
              const city = this.cities[i];
              if (Math.hypot(city.x - this.mouseX, city.y - this.mouseY) < 8) {
                hoveredCity = { index: i, ...city };
                break;
              }
            }

            // Check paths (if no city hovered)
            if (!hoveredCity) {
              // Check in reverse order (top to bottom visually)
              for (let k = this.nodes.length - 1; k >= 0; k--) {
                const node = this.nodes[k];
                if (node.type === "leaf" && node.visible && node.bestGenome) {
                  if (this.isMouseOnPath(node.bestGenome)) {
                    hoveredNode = node;
                    break;
                  }
                }
              }
            }

            // Draw Highlights & Tooltips
            if (hoveredNode) {
              // Highlight path
              this.ctx.shadowBlur = 15;
              this.ctx.shadowColor = hoveredNode.color;
              this.drawPath(hoveredNode.bestGenome, hoveredNode.color, true); // Redraw as primary
              this.ctx.shadowBlur = 0;

              this.drawTooltip(
                `Sol ${hoveredNode.id}: ${hoveredNode.bestDistance.toFixed(0)}${this.problemId.startsWith("MSTSP-") ? "" : " km"}`,
                this.mouseX,
                this.mouseY,
              );
            }

            if (hoveredCity) {
              // Highlight city
              this.ctx.beginPath();
              this.ctx.arc(hoveredCity.x, hoveredCity.y, 6, 0, Math.PI * 2);
              this.ctx.fillStyle = "#3b82f6"; // blue-500
              this.ctx.fill();
              this.ctx.strokeStyle = "white";
              this.ctx.lineWidth = 2;
              this.ctx.stroke();

              // Determine tooltip text
              let tooltipText = `City ${hoveredCity.index}`;
              // If it's a convenience store problem (not MSTSP), show name + address
              if (!this.problemId.startsWith("MSTSP-")) {
                // Find original data point
                // hoveredCity.index corresponds to this.cities[index]
                // which corresponds to this.originalCities[index]
                const originalData = this.originalCities[hoveredCity.index];
                if (originalData && originalData.name && originalData.address) {
                  tooltipText = `${originalData.name} ${originalData.address}`;
                }
              }

              this.drawTooltip(tooltipText, hoveredCity.x, hoveredCity.y - 10);
            }
          },

          drawPath(genome, color, isPrimary) {
            let currentPos = this.depot;

            this.ctx.lineWidth = isPrimary ? 3 : 1.5;
            this.ctx.lineJoin = "round";
            this.ctx.lineCap = "round";

            this.ctx.beginPath();
            this.ctx.strokeStyle = color;
            // Add transparency to non-primary solutions
            this.ctx.globalAlpha = isPrimary ? 1.0 : 0.6;

            this.ctx.moveTo(currentPos.x, currentPos.y);

            for (let i = 0; i < genome.length; i++) {
              const index = genome[i];
              const nextPos = this.cities[index];
              this.ctx.lineTo(nextPos.x, nextPos.y);
            }

            this.ctx.lineTo(this.depot.x, this.depot.y);
            this.ctx.stroke();
            this.ctx.globalAlpha = 1.0;
          },
        };
      }
    </script>
  </body>
</html>
