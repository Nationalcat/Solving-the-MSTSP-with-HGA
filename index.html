<!doctype html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <title>mTSP Visualization</title>
    <style>
      canvas {
        touch-action: none;
      }
    </style>
    <script src="src/tests/mstsp.js"></script>
  </head>
  <body
    class="bg-gray-900 text-white h-screen flex flex-col overflow-hidden"
    x-data="mtspApp()"
    x-init="initApp()"
  >
    <!-- Header / Controls -->
    <header
      class="p-4 bg-gray-800 shadow-lg z-10 flex flex-wrap gap-6 items-center justify-between border-b border-gray-700"
    >
      <div class="flex items-center gap-3">
        <div class="p-2 bg-purple-600 rounded-lg">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-6 w-6 text-white"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 7m0 13V7m0 0L9.553 4.553A1 1 0 009 3.618"
            />
          </svg>
        </div>
        <div>
          <h1 class="text-xl font-bold text-gray-100 tracking-wide">
            Multi-Solution TSP
          </h1>
          <div class="text-xs text-gray-400">多模態/多解路徑規劃</div>
        </div>
      </div>

      <div class="flex flex-wrap gap-6 items-center">
        <!-- Mode Control -->
        <div class="flex flex-col gap-1">
          <label class="text-xs text-gray-400 font-medium">模式</label>
          <select
            x-model="mode"
            @change="reset()"
            class="bg-gray-700 text-white text-xs rounded px-2 py-1 border border-gray-600 focus:outline-none focus:border-blue-500 h-[26px]"
          >
            <option value="random">隨機生成</option>
            <option value="fixed">固定問題</option>
          </select>
        </div>

        <!-- Problem ID Control (Visible only in Fixed Mode) -->
        <div class="flex flex-col gap-1" x-show="mode === 'fixed'">
          <label class="text-xs text-gray-400 font-medium">問題 ID</label>
          <select
            x-model.number="problemId"
            @change="reset()"
            class="bg-gray-700 text-white text-xs rounded px-2 py-1 border border-gray-600 focus:outline-none focus:border-blue-500 h-[26px] w-24"
          >
            <template x-for="i in 25">
              <option :value="`MSTSP-${i}`" x-text="`MSTSP-${i}`"></option>
            </template>
          </select>
        </div>

        <!-- Cities Control -->
        <div class="flex flex-col gap-1" x-show="mode === 'random'">
          <div class="flex justify-between">
            <label class="text-xs text-gray-400 font-medium">城市 (N)</label>
            <span
              class="text-xs text-blue-400 font-bold"
              x-text="cityCount"
            ></span>
          </div>
          <input
            type="range"
            min="5"
            max="100"
            x-model.number="cityCount"
            @input="scheduleReset()"
            class="w-24 h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500"
          />
        </div>

        <!-- Salesmen Control -->
        <div class="flex flex-col gap-1">
          <div class="flex justify-between">
            <label class="text-xs text-gray-400 font-medium">旅行商 (m)</label>
            <span
              class="text-xs text-green-400 font-bold"
              x-text="salesmenCount"
            ></span>
          </div>
          <input
            type="range"
            min="1"
            :max="cityCount"
            x-model.number="salesmenCount"
            @input="scheduleReset()"
            class="w-24 h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-green-500"
          />
        </div>

        <!-- Solutions Control -->
        <div class="flex flex-col gap-1">
          <div class="flex justify-between">
            <label class="text-xs text-gray-400 font-medium">解數量 (k)</label>
            <span
              class="text-xs text-purple-400 font-bold"
              x-text="solutionCount"
            ></span>
          </div>
          <input
            type="range"
            min="1"
            max="5"
            x-model.number="solutionCount"
            @input="scheduleReset()"
            class="w-24 h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-purple-500"
          />
        </div>

        <!-- Buttons -->
        <div class="flex gap-3 items-end h-full pb-1">
          <button
            @click="reset()"
            class="px-4 py-1.5 bg-gray-700 hover:bg-gray-600 rounded text-sm font-medium transition border border-gray-600 hover:border-gray-500"
          >
            重置
          </button>
          <button
            @click="toggle()"
            class="px-4 py-1.5 rounded text-sm font-bold transition w-24 shadow-lg"
            :class="running ? 'bg-red-500 hover:bg-red-600 text-white shadow-red-500/30' : 'bg-blue-500 hover:bg-blue-600 text-white shadow-blue-500/30'"
            x-text="running ? '停止' : '開始'"
          ></button>
        </div>
      </div>

      <div class="flex flex-col items-end min-w-[100px]">
        <div class="text-xs text-gray-400">最佳距離</div>
        <div
          x-text="globalBestDistance.toFixed(0)"
          class="text-white font-mono text-xl font-bold text-shadow"
        >
          0
        </div>
        <div class="text-xs text-gray-500 mt-1">
          迭代:
          <span x-text="generation" class="font-mono text-gray-300">0</span>
        </div>

        <!-- Metrics Display (Only in Fixed Mode) -->
        <div x-show="mode === 'fixed'" class="mt-2 flex flex-col items-end">
          <div
            class="text-[10px] text-gray-400 uppercase tracking-wider mb-0.5"
          >
            F-Beta
          </div>
          <div
            class="text-sm font-mono font-bold"
            :class="fBeta > 0.8 ? 'text-green-400' : 'text-yellow-400'"
            x-text="fBeta.toFixed(3)"
          >
            0.000
          </div>

          <div
            class="text-[10px] text-gray-400 uppercase tracking-wider mt-1 mb-0.5"
          >
            Diversity
          </div>
          <div
            class="text-sm font-mono font-bold text-blue-400"
            x-text="diversity.toFixed(3)"
          >
            0.000
          </div>
        </div>
      </div>
    </header>

    <!-- Main Canvas Area -->
    <main
      class="flex-1 relative bg-gray-900 cursor-crosshair overflow-hidden"
      id="canvas-container"
    >
      <canvas
        id="mainCanvas"
        class="block w-full h-full"
        @mousemove="handleMouseMove($event)"
        @mouseleave="handleMouseLeave()"
      ></canvas>

      <!-- Legend -->
      <div
        class="absolute bottom-6 left-6 bg-gray-800/90 p-4 rounded-xl backdrop-blur-md border border-gray-700 shadow-xl"
      >
        <h3
          class="text-xs font-bold text-gray-400 mb-3 uppercase tracking-wider"
        >
          圖例
        </h3>
        <div class="flex items-center gap-3 mb-2">
          <div
            class="w-3 h-3 rounded-full bg-white shadow-[0_0_8px_rgba(255,255,255,0.5)]"
          ></div>
          <span class="text-sm text-gray-200">城市 (City)</span>
        </div>
        <div class="flex items-center gap-3 mb-4">
          <div
            class="w-5 h-5 bg-red-500 rounded flex items-center justify-center text-[10px] font-bold shadow-[0_0_8px_rgba(239,68,68,0.5)]"
          >
            D
          </div>
          <span class="text-sm text-gray-200">倉庫 (Depot)</span>
        </div>

        <h3
          class="text-xs font-bold text-gray-400 mb-2 uppercase tracking-wider"
        >
          解決方案 (Solutions)
        </h3>
        <template x-for="(sol, index) in bestSolutions" :key="index">
          <div
            class="flex items-center gap-3 mb-1 cursor-pointer hover:bg-gray-700/50 p-1 rounded"
            x-show="index < solutionCount"
            @click="sol.visible = !sol.visible; if(!running) draw()"
          >
            <div
              class="w-3 h-3 rounded border flex items-center justify-center transition-colors"
              :class="sol.visible ? 'bg-blue-500 border-blue-500' : 'border-gray-500 bg-transparent'"
            >
              <svg
                x-show="sol.visible"
                class="w-2 h-2 text-white"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="4"
                  d="M5 13l4 4L19 7"
                ></path>
              </svg>
            </div>
            <div
              class="w-8 h-1 rounded"
              :style="`background-color: ${sol.color}; opacity: ${sol.visible ? 1 : 0.3}`"
            ></div>
            <span
              class="text-xs text-gray-300 font-mono select-none"
              x-text="`Sol ${index+1}: ${sol.distance === Infinity ? '-' : sol.distance.toFixed(0)}`"
              :class="{'opacity-50': !sol.visible}"
            ></span>
          </div>
        </template>
      </div>
    </main>

    <script>
      function mtspApp() {
        return {
          cityCount: 30,
          salesmenCount: 1,
          solutionCount: 3, // Number of islands/solutions
          mode: "fixed", // 'random' or 'fixed'
          problemId: 1,
          groundTruth: {
            1: { optLength: 680, optCount: 3 },
            2: { optLength: 1265, optCount: 4 },
            3: { optLength: 832, optCount: 13 },
            4: { optLength: 803, optCount: 4 },
            5: { optLength: 754, optCount: 2 },
            6: { optLength: 845, optCount: 4 },
            7: { optLength: 130, optCount: 56 },
            8: { optLength: 1344, optCount: 110 },
            9: { optLength: 72, optCount: 4 },
            10: { optLength: 72, optCount: 4 },
            11: { optLength: 78, optCount: 14 },
            12: { optLength: 130, optCount: 196 },
            13: { optLength: 3055, optCount: 70 },
            14: { optLength: 3575, optCount: 16 },
            15: { optLength: 9455, optCount: 72 },
            16: { optLength: 8761, optCount: 64 },
            17: { optLength: 9061, optCount: 10 },
            18: { optLength: 23763, optCount: 20 },
            19: { optLength: 14408, optCount: 20 },
            20: { optLength: 10973, optCount: 20 },
            21: { optLength: 6767, optCount: 4 },
            22: { optLength: 10442, optCount: 9 },
            23: { optLength: 24451, optCount: 10 },
            24: { optLength: 9614, optCount: 36 },
            25: { optLength: 9521, optCount: 26 },
          },
          problems: {},
          running: false,
          generation: 0,
          globalBestDistance: 0,

          // Internal state
          canvas: null,
          ctx: null,
          width: 0,
          height: 0,
          cities: [],
          depot: { x: 0, y: 0 },

          // Evaluation coordinates (Original scale for Fixed, Screen scale for Random)
          evalCities: [],
          evalDepot: { x: 0, y: 0 },

          mouseX: -1,
          mouseY: -1,

          // Metrics
          fBeta: 0,
          diversity: 0,

          // LCG Seed
          _seed: 1,

          seededRandom() {
            const x = Math.sin(this._seed++) * 10000;
            return x - Math.floor(x);
          },

          generateFixedCities(id) {
            if (this.problems[id]) {
              const data = this.problems[id];

              // Extract Depot (First point) and Cities (Rest)
              // We assume the first point in the dataset is the Depot for mTSP/VRP
              this.originalDepot = data[0];
              this.originalCities = data.slice(1);
              this.cityCount = this.originalCities.length;

              // Find bounds (using ALL points including depot)
              let minX = Infinity,
                maxX = -Infinity;
              let minY = Infinity,
                maxY = -Infinity;

              data.forEach((p) => {
                if (p.x < minX) minX = p.x;
                if (p.x > maxX) maxX = p.x;
                if (p.y < minY) minY = p.y;
                if (p.y > maxY) maxY = p.y;
              });

              const margin = 50;
              const availW = this.width - 2 * margin;
              const availH = this.height - 2 * margin;

              const rangeX = maxX - minX;
              const rangeY = maxY - minY;

              // Scale to fit while maintaining aspect ratio
              const scaleX = rangeX === 0 ? 1 : availW / rangeX;
              const scaleY = rangeY === 0 ? 1 : availH / rangeY;
              const scale = Math.min(scaleX, scaleY);

              // Center the content
              const contentW = rangeX * scale;
              const contentH = rangeY * scale;
              const offsetX = margin + (availW - contentW) / 2;
              const offsetY = margin + (availH - contentH) / 2;

              // Set Screen Coordinates
              this.depot = {
                x: offsetX + (this.originalDepot.x - minX) * scale,
                y: offsetY + (this.originalDepot.y - minY) * scale,
              };

              this.cities = this.originalCities.map((p) => ({
                x: offsetX + (p.x - minX) * scale,
                y: offsetY + (p.y - minY) * scale,
              }));

              return;
            }

            this._seed = id * 12345;

            // Simulate different problem sizes
            // MSTSP often uses grid-like or symmetric structures
            // Here we generate deterministic random cities
            let n = 20;
            if (id <= 5)
              n = 10 + id * 2; // 12, 14, 16, 18, 20
            else if (id <= 15) n = 30;
            else n = 50;

            this.cityCount = n;

            const margin = 50;
            for (let i = 0; i < n; i++) {
              this.cities.push({
                x: margin + this.seededRandom() * (this.width - 2 * margin),
                y: margin + this.seededRandom() * (this.height - 2 * margin),
              });
            }
          },

          // HGA Structure
          // Tree Topology: 1 Root -> 3 Leaves (Sub-populations)
          // Node structure: { id, population, bestGenome, bestDistance, color }
          nodes: [],

          // Parameters
          popSize: 50,
          migrationInterval: 10,
          clearingRadius: 0.2, // Similarity threshold for clearing (20%)

          // Visualization colors for different solutions
          solutionColors: [
            "#00ffff", // Cyan
            "#ff00ff", // Magenta
            "#ffff00", // Yellow
            "#00ff00", // Green
            "#ff8800", // Orange
          ],

          // Path colors for salesmen within a solution (if m > 1)
          salesmenColors: [
            "#3490dc",
            "#ffed4a",
            "#38c172",
            "#e3342f",
            "#9561e2",
            "#f66d9b",
            "#6574cd",
            "#4dc0b5",
            "#f6993f",
            "#6cb2eb",
          ],

          initApp() {
            this.canvas = document.getElementById("mainCanvas");
            this.ctx = this.canvas.getContext("2d");
            this.problems = mstspProblems

            const resize = () => {
              const container = document.getElementById("canvas-container");
              this.canvas.width = container.clientWidth;
              this.canvas.height = container.clientHeight;
              this.width = this.canvas.width;
              this.height = this.canvas.height;
              if (!this.running) this.draw();
            };
            window.addEventListener("resize", resize);
            resize();

            this.reset();
          },

          scheduleReset() {
            if (this.resetTimeout) clearTimeout(this.resetTimeout);
            this.resetTimeout = setTimeout(() => this.reset(), 100);
          },

          reset() {
            this.stop();
            this.generation = 0;
            this.globalBestDistance = Infinity;
            this.foundOptima = new Set();

            // Initialize Depot
            this.depot = { x: this.width / 2, y: this.height / 2 };

            // Initialize Cities
            this.cities = [];

            if (this.mode === "fixed") {
              this.generateFixedCities(this.problemId);
              // Use Original Coordinates for Evaluation
              this.evalCities = this.originalCities;
              this.evalDepot = this.originalDepot;
            } else {
              const margin = 50;
              for (let i = 0; i < this.cityCount; i++) {
                this.cities.push({
                  x: margin + Math.random() * (this.width - 2 * margin),
                  y: margin + Math.random() * (this.height - 2 * margin),
                });
              }
              // Use Screen Coordinates for Evaluation
              this.evalCities = this.cities;
              this.evalDepot = this.depot;
            }

            // Initialize HGA Tree Structure
            this.nodes = [];
            this.bestSolutions = []; // Clear bestSolutions

            // Ensure salesmenCount <= cityCount
            if (this.salesmenCount > this.cityCount) {
              this.salesmenCount = this.cityCount;
            }

            // Create Root Node (ID: 0)
            this.nodes.push({
              id: 0,
              type: "root",
              population: [],
              bestGenome: null,
              bestDistance: Infinity,
              color: "#ffffff",
              visible: false,
            });

            // Create Leaf Nodes (ID: 1 to k)
            for (let k = 0; k < this.solutionCount; k++) {
              const color = this.solutionColors[k % this.solutionColors.length];

              // Create Node
              this.nodes.push({
                id: k + 1,
                type: "leaf",
                population: [],
                bestGenome: null,
                bestDistance: Infinity,
                color: color,
                visible: true,
              });

              // Create corresponding bestSolution entry for UI
              this.bestSolutions.push({
                genome: null,
                distance: Infinity,
                color: color,
                visible: true,
              });
            }

            // Initialize Populations for all nodes
            this.nodes.forEach((node) => {
              for (let i = 0; i < this.popSize; i++) {
                node.population.push(this.createValidGenome());
              }
            });

            this.evaluate();
            this.draw();
          },

          toggle() {
            if (this.running) this.stop();
            else this.start();
          },

          start() {
            if (this.running) return;
            this.running = true;
            this.loop();
          },

          stop() {
            this.running = false;
            if (this.animationId) {
              cancelAnimationFrame(this.animationId);
              this.animationId = null;
            }
          },

          loop() {
            if (!this.running) return;

            for (let i = 0; i < 5; i++) {
              this.evolve();
              this.generation++;
            }

            this.draw();
            this.animationId = requestAnimationFrame(() => this.loop());
          },

          // --- GA Logic ---

          createValidGenome() {
            let cities = Array.from({ length: this.cityCount }, (_, i) => i);
            this.shuffle(cities);

            if (this.salesmenCount === 1) return cities;

            // mTSP Logic for > 1 salesman
            if (this.salesmenCount > this.cityCount) {
              return this.shuffle(
                Array.from(
                  { length: this.cityCount + this.salesmenCount - 1 },
                  (_, i) => i,
                ),
              );
            }

            let possibleSplits = Array.from(
              { length: this.cityCount - 1 },
              (_, i) => i + 1,
            );
            this.shuffle(possibleSplits);
            let splits = possibleSplits
              .slice(0, this.salesmenCount - 1)
              .sort((a, b) => a - b);

            let genome = [];
            let currentCityIdx = 0;
            let separatorIdx = this.cityCount;

            for (let split of splits) {
              while (currentCityIdx < split)
                genome.push(cities[currentCityIdx++]);
              genome.push(separatorIdx++);
            }
            while (currentCityIdx < this.cityCount)
              genome.push(cities[currentCityIdx++]);

            return genome;
          },

          shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
          },

          evaluate() {
            let globalBest = Infinity;

            // Evaluate each node independently
            this.nodes.forEach((node) => {
              let nodeBestDist = Infinity;
              let nodeBestGenome = null;

              node.population.forEach((genome) => {
                const dist = this.calculateDistance(genome);
                genome.fitness = 1 / (dist + 1);
                genome.distance = dist;

                if (dist < nodeBestDist) {
                  nodeBestDist = dist;
                  nodeBestGenome = [...genome];
                }
              });

              // Update node best
              if (nodeBestGenome) {
                node.bestDistance = nodeBestDist;
                node.bestGenome = nodeBestGenome;
              }

              // Track global best (from any node)
              if (node.bestDistance < globalBest) {
                globalBest = node.bestDistance;
              }
            });

            if (globalBest < Infinity) {
              this.globalBestDistance = globalBest;
            }
          },

          // Calculate similarity between two genomes based on shared edges
          calculateSimilarity(g1, g2) {
            if (!g1 || !g2 || g1.length !== g2.length) return 0;

            const getEdges = (genome) => {
              const edges = new Set();
              let currentCity = -1; // -1 is Depot

              for (let i = 0; i < genome.length; i++) {
                let nextCity = genome[i];
                if (nextCity >= this.cityCount) nextCity = -1;

                const u = currentCity;
                const v = nextCity;
                edges.add(u < v ? `${u}_${v}` : `${v}_${u}`);

                currentCity = nextCity;
              }
              // Return to depot
              const u = currentCity;
              const v = -1;
              edges.add(u < v ? `${u}_${v}` : `${v}_${u}`);
              return edges;
            };

            const edges1 = getEdges(g1);
            const edges2 = getEdges(g2);

            let shared = 0;
            edges2.forEach((e) => {
              if (edges1.has(e)) shared++;
            });

            // Jaccard Similarity or just Overlap?
            // Usually for TSP edges: shared / total_edges_in_one_solution
            // Since both have same number of edges (N + m), we can divide by size.
            return shared / edges1.size;
          },

          getCanonicalSignature(genome) {
            const edges = [];
            let currentCity = -1; // -1 represents Depot

            for (let i = 0; i < genome.length; i++) {
              let nextCity = genome[i];
              if (nextCity >= this.cityCount) nextCity = -1;

              const u = currentCity;
              const v = nextCity;
              edges.push(u < v ? `${u}_${v}` : `${v}_${u}`);

              currentCity = nextCity;
            }
            // Return to depot
            const u = currentCity;
            const v = -1;
            edges.push(u < v ? `${u}_${v}` : `${v}_${u}`);

            edges.sort();
            return edges.join("|");
          },

          calculateMetrics() {
            if (!this.groundTruth || !this.groundTruth[this.problemId]) return;

            const gt = this.groundTruth[this.problemId];
            // Increased tolerance to handle float precision vs integer ground truth
            const tolerance = 1.0;

            // 1. Update Found Optima
            this.nodes.forEach((node) => {
              if (
                node.bestGenome &&
                Math.abs(node.bestDistance - gt.optLength) < tolerance
              ) {
                const sig = this.getCanonicalSignature(node.bestGenome);
                this.foundOptima.add(sig);
              }
            });

            // 2. Calculate F-Beta
            const R = this.foundOptima.size / gt.optCount;
            const P = 1.0;
            const betaSq = 0.3;

            if (P + R === 0) {
              this.fBeta = 0;
            } else {
              this.fBeta = ((1 + betaSq) * P * R) / (betaSq * P + R);
            }

            // 3. Calculate Diversity (1 - Average Similarity of best solutions)
            let totalSim = 0;
            let pairCount = 0;
            const solutions = this.nodes
              .map((n) => n.bestGenome)
              .filter((g) => g);

            if (solutions.length < 2) {
              this.diversity = 0;
            } else {
              for (let i = 0; i < solutions.length; i++) {
                for (let j = i + 1; j < solutions.length; j++) {
                  totalSim += this.calculateSimilarity(
                    solutions[i],
                    solutions[j],
                  );
                  pairCount++;
                }
              }
              const avgSim = totalSim / pairCount;
              this.diversity = 1 - avgSim;
            }
          },

          calculateDistance(genome) {
            let totalDist = 0;
            // Use evaluation coordinates (Original or Screen)
            const useCities = this.evalCities || this.cities;
            const useDepot = this.evalDepot || this.depot;

            let currentPos = useDepot;
            let citiesInRoute = 0;
            let penalty = 0;
            const PENALTY_AMOUNT = 100000;

            for (let i = 0; i < genome.length; i++) {
              const index = genome[i];
              let nextPos;

              if (index < this.cityCount) {
                nextPos = useCities[index];
                citiesInRoute++;
              } else {
                if (citiesInRoute === 0) penalty += PENALTY_AMOUNT;
                nextPos = useDepot;
                citiesInRoute = 0;
              }

              totalDist += Math.hypot(
                currentPos.x - nextPos.x,
                currentPos.y - nextPos.y,
              );
              currentPos = nextPos;
            }

            if (citiesInRoute === 0 && this.salesmenCount > 1)
              penalty += PENALTY_AMOUNT;

            totalDist += Math.hypot(
              currentPos.x - useDepot.x,
              currentPos.y - useDepot.y,
            );

            return totalDist + penalty;
          },

          evolve() {
            // 1. Parallel Evolution for each Node
            this.nodes.forEach((node) => {
              this.evolveNode(node);
            });

            // 2. Hierarchical Migration (Bottom-Up)
            if (
              this.generation > 0 &&
              this.generation % this.migrationInterval === 0
            ) {
              this.migrate();
            }

            this.evaluate();
            this.calculateMetrics();
          },

          evolveNode(node) {
            const newPop = [];

            // Elitism
            node.population.sort((a, b) => b.fitness - a.fitness);
            const eliteCount = Math.floor(this.popSize * 0.05);
            for (let i = 0; i < eliteCount; i++)
              newPop.push([...node.population[i]]);

            // Standard GA Loop
            while (newPop.length < this.popSize) {
              const p1 = this.tournamentSelect(node.population);
              const p2 = this.tournamentSelect(node.population);
              let child = this.crossover(p1, p2);
              if (Math.random() < 0.1) this.mutate(child);
              newPop.push(child);
            }

            // Apply Clearing (Niching) within the node?
            // Or is Clearing applied globally?
            // The paper usually applies Clearing to maintain diversity *within* a node
            // OR to ensure nodes are distinct.
            // Here we apply a simple clearing: if individuals are too similar to the best, penalize them?
            // Actually, standard GA within node is fine. The distinctness comes from independent evolution + migration logic.

            node.population = newPop;
          },

          migrate() {
            // Bottom-Up Migration: Leaves -> Root
            // 1. Identify best from each Leaf
            const leafBests = [];
            this.nodes.forEach((node) => {
              if (node.type === "leaf" && node.bestGenome) {
                leafBests.push({
                  genome: [...node.bestGenome],
                  fitness: 1 / (node.bestDistance + 1),
                });
              }
            });

            // 2. Send to Root
            const rootNode = this.nodes[0];
            // Replace worst individuals in Root with Leaf Bests
            rootNode.population.sort((a, b) => b.fitness - a.fitness); // Best first

            let replaceIdx = rootNode.population.length - 1;
            leafBests.forEach((migrant) => {
              if (replaceIdx >= 0) {
                rootNode.population[replaceIdx] = migrant.genome;
                replaceIdx--;
              }
            });

            // 3. Top-Down? (Optional, some HGA do this)
            // Root sends its best back to leaves to guide them?
            // The paper emphasizes Bottom-Up for collecting solutions.
            // But to help leaves converge, Root can also seed them.
            // Let's implement a "Clearing" check here:
            // If two leaves are too similar, force one to diverge (restart/mutate).

            for (let i = 1; i < this.nodes.length; i++) {
              for (let j = i + 1; j < this.nodes.length; j++) {
                const nodeA = this.nodes[i];
                const nodeB = this.nodes[j];

                if (nodeA.bestGenome && nodeB.bestGenome) {
                  const sim = this.calculateSimilarity(
                    nodeA.bestGenome,
                    nodeB.bestGenome,
                  );
                  if (sim > 0.8) {
                    // Too similar
                    // Penalize the worse one (reset its population to explore elsewhere)
                    const worseNode =
                      nodeA.bestDistance > nodeB.bestDistance ? nodeA : nodeB;
                    // Heavy mutation on the worse node's population to force divergence
                    worseNode.population.forEach((g) => this.mutate(g)); // Mutate everyone
                  }
                }
              }
            }
          },

          tournamentSelect(pop) {
            const k = 5;
            let best = null;
            for (let i = 0; i < k; i++) {
              const ind = pop[Math.floor(Math.random() * pop.length)];
              if (!best || ind.fitness > best.fitness) best = ind;
            }
            return best;
          },

          crossover(p1, p2) {
            const start = Math.floor(Math.random() * p1.length);
            const end = Math.floor(Math.random() * (p1.length - start)) + start;
            const child = new Array(p1.length).fill(-1);

            for (let i = start; i <= end; i++) child[i] = p1[i];

            let p2Idx = 0;
            for (let i = 0; i < child.length; i++) {
              if (i >= start && i <= end) continue;
              while (child.includes(p2[p2Idx])) p2Idx++;
              child[i] = p2[p2Idx];
            }
            return child;
          },

          mutate(genome) {
            const i = Math.floor(Math.random() * genome.length);
            const j = Math.floor(Math.random() * genome.length);
            [genome[i], genome[j]] = [genome[j], genome[i]];

            if (Math.random() < 0.5) {
              const a = Math.floor(Math.random() * genome.length);
              const b = Math.floor(Math.random() * genome.length);
              const start = Math.min(a, b);
              const end = Math.max(a, b);
              let left = start,
                right = end;
              while (left < right) {
                [genome[left], genome[right]] = [genome[right], genome[left]];
                left++;
                right--;
              }
            }
          },

          // --- Drawing ---

          handleMouseMove(e) {
            const rect = this.canvas.getBoundingClientRect();
            this.mouseX = e.clientX - rect.left;
            this.mouseY = e.clientY - rect.top;
            if (!this.running) this.draw();
          },

          handleMouseLeave() {
            this.mouseX = -1;
            this.mouseY = -1;
            if (!this.running) this.draw();
          },

          pointToLineDistance(x, y, x1, y1, x2, y2) {
            const A = x - x1;
            const B = y - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const len_sq = C * C + D * D;
            let param = -1;
            if (len_sq !== 0) param = dot / len_sq;

            let xx, yy;

            if (param < 0) {
              xx = x1;
              yy = y1;
            } else if (param > 1) {
              xx = x2;
              yy = y2;
            } else {
              xx = x1 + param * C;
              yy = y1 + param * D;
            }

            const dx = x - xx;
            const dy = y - yy;
            return Math.sqrt(dx * dx + dy * dy);
          },

          isMouseOnPath(genome) {
            if (this.mouseX < 0) return false;
            const threshold = 8; // Tolerance in pixels
            let currentPos = this.depot;

            for (let i = 0; i < genome.length; i++) {
              const index = genome[i];
              let nextPos;

              if (index < this.cityCount) {
                nextPos = this.cities[index];
              } else {
                nextPos = this.depot;
              }

              if (
                this.pointToLineDistance(
                  this.mouseX,
                  this.mouseY,
                  currentPos.x,
                  currentPos.y,
                  nextPos.x,
                  nextPos.y,
                ) < threshold
              ) {
                return true;
              }

              currentPos = nextPos;
            }

            // Last segment back to depot
            if (
              this.pointToLineDistance(
                this.mouseX,
                this.mouseY,
                currentPos.x,
                currentPos.y,
                this.depot.x,
                this.depot.y,
              ) < threshold
            ) {
              return true;
            }

            return false;
          },

          drawTooltip(text, x, y) {
            this.ctx.font = "12px sans-serif";
            const metrics = this.ctx.measureText(text);
            const padding = 6;
            const w = metrics.width + padding * 2;
            const h = 24;

            // Keep tooltip within bounds
            let tx = x + 10;
            let ty = y - 10;
            if (tx + w > this.width) tx = x - w - 10;
            if (ty < 0) ty = y + 20;

            this.ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
            this.ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
            this.ctx.lineWidth = 1;

            this.ctx.beginPath();
            this.ctx.roundRect(tx, ty, w, h, 4);
            this.ctx.fill();
            this.ctx.stroke();

            this.ctx.fillStyle = "white";
            this.ctx.textBaseline = "middle";
            this.ctx.textAlign = "left";
            this.ctx.fillText(text, tx + padding, ty + h / 2);
          },

          draw() {
            this.ctx.fillStyle = "#111827";
            this.ctx.fillRect(0, 0, this.width, this.height);

            // Draw Solutions (Leaves)
            for (let k = this.nodes.length - 1; k >= 1; k--) {
              const node = this.nodes[k];
              const solIdx = k - 1;
              if (this.bestSolutions[solIdx]) {
                this.bestSolutions[solIdx].distance = node.bestDistance;
                this.bestSolutions[solIdx].genome = node.bestGenome;

                if (node.bestGenome && this.bestSolutions[solIdx].visible) {
                  this.drawPath(node.bestGenome, node.color, solIdx === 0);
                }
              }
            }

            // Draw Cities
            this.cities.forEach((city) => {
              this.ctx.beginPath();
              this.ctx.arc(city.x, city.y, 4, 0, Math.PI * 2);
              this.ctx.fillStyle = "white";
              this.ctx.fill();
            });

            // Draw Depot
            this.ctx.beginPath();
            this.ctx.rect(this.depot.x - 8, this.depot.y - 8, 16, 16);
            this.ctx.fillStyle = "#ef4444";
            this.ctx.fill();
            this.ctx.strokeStyle = "white";
            this.ctx.lineWidth = 2;
            this.ctx.stroke();
            this.ctx.fillStyle = "white";
            this.ctx.font = "bold 10px sans-serif";
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";
            this.ctx.fillText("D", this.depot.x, this.depot.y);

            // --- Interaction ---
            let hoveredCity = null;
            let hoveredSolIndex = -1;

            // Check cities
            for (let i = 0; i < this.cities.length; i++) {
              const city = this.cities[i];
              if (Math.hypot(city.x - this.mouseX, city.y - this.mouseY) < 8) {
                hoveredCity = { index: i, ...city };
                break;
              }
            }

            // Check paths (if no city hovered)
            if (!hoveredCity) {
              // Check in reverse order (top to bottom visually)
              for (let k = this.nodes.length - 1; k >= 1; k--) {
                const solIdx = k - 1;
                const sol = this.bestSolutions[solIdx];
                if (sol && sol.visible && sol.genome) {
                  if (this.isMouseOnPath(sol.genome)) {
                    hoveredSolIndex = solIdx;
                    break;
                  }
                }
              }
            }

            // Draw Highlights & Tooltips
            if (hoveredSolIndex !== -1) {
              const sol = this.bestSolutions[hoveredSolIndex];
              // Highlight path
              this.ctx.shadowBlur = 15;
              this.ctx.shadowColor = sol.color;
              this.drawPath(sol.genome, sol.color, true); // Redraw as primary
              this.ctx.shadowBlur = 0;

              this.drawTooltip(
                `Sol ${hoveredSolIndex + 1}: ${sol.distance.toFixed(0)}`,
                this.mouseX,
                this.mouseY,
              );
            }

            if (hoveredCity) {
              // Highlight city
              this.ctx.beginPath();
              this.ctx.arc(hoveredCity.x, hoveredCity.y, 6, 0, Math.PI * 2);
              this.ctx.fillStyle = "#3b82f6"; // blue-500
              this.ctx.fill();
              this.ctx.strokeStyle = "white";
              this.ctx.lineWidth = 2;
              this.ctx.stroke();

              this.drawTooltip(
                `City ${hoveredCity.index}`,
                hoveredCity.x,
                hoveredCity.y - 10,
              );
            }
          },

          drawPath(genome, color, isPrimary) {
            let currentPos = this.depot;
            let salesmanIndex = 0;

            this.ctx.lineWidth = isPrimary ? 3 : 1.5;
            this.ctx.lineJoin = "round";
            this.ctx.lineCap = "round";

            // If mTSP (m > 1), we might want to use different colors for salesmen
            // BUT for Multi-Solution view, it's better to color by Solution ID.
            // So we use the passed 'color' for the whole path.
            // To distinguish salesmen in mTSP mode, we can use dashes or just keep it simple.
            // Let's stick to single color per Solution for clarity.

            this.ctx.beginPath();
            this.ctx.strokeStyle = color;
            // Add transparency to non-primary solutions
            this.ctx.globalAlpha = isPrimary ? 1.0 : 0.6;

            this.ctx.moveTo(currentPos.x, currentPos.y);

            for (let i = 0; i < genome.length; i++) {
              const index = genome[i];
              let nextPos;
              let isDepot = false;

              if (index < this.cityCount) {
                nextPos = this.cities[index];
              } else {
                nextPos = this.depot;
                isDepot = true;
              }

              this.ctx.lineTo(nextPos.x, nextPos.y);

              if (isDepot) {
                this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.moveTo(nextPos.x, nextPos.y);
              }
            }

            this.ctx.lineTo(this.depot.x, this.depot.y);
            this.ctx.stroke();
            this.ctx.globalAlpha = 1.0;
          },
        };
      }
    </script>
  </body>
</html>
